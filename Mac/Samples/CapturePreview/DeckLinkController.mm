/* -LICENSE-START-
 ** Copyright (c) 2011 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 ** 
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 ** 
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

#include "DeckLinkController.h"

using namespace std;

DeckLinkController::DeckLinkController(CapturePreviewAppDelegate* delegate)
	: uiDelegate(delegate), selectedDevice(NULL), deckLinkInput(NULL), 
	screenPreviewCallback(NULL), supportFormatDetection(false), currentlyCapturing(false)
{}


DeckLinkController::~DeckLinkController()
{
	vector<IDeckLink*>::iterator it;
	
	// Release screen preview
	if (screenPreviewCallback != NULL)
	{
		screenPreviewCallback->Release();
		screenPreviewCallback = NULL;
	}
		
	// Release the IDeckLink list
	for(it = deviceList.begin(); it != deviceList.end(); it++)
	{
		(*it)->Release();
	}
}


bool		DeckLinkController::init(NSView *previewView)
{
	IDeckLinkIterator*	deckLinkIterator = NULL;
	IDeckLink*			deckLink = NULL;
	bool				result = false;
	
	// Create an iterator
	deckLinkIterator = CreateDeckLinkIteratorInstance();
	if (deckLinkIterator == NULL)
	{
		[uiDelegate showErrorMessage:@"This application requires the Desktop Video drivers installed." title:@"Please install the Blackmagic Desktop Video drivers to use the features of this application."];
		goto bail;
	}
	
	// List all DeckLink devices
	while (deckLinkIterator->Next(&deckLink) == S_OK)
	{
		// Add device to the device list
		deviceList.push_back(deckLink);
	}
	
	if (deviceList.size() == 0)
	{
		[uiDelegate showErrorMessage:@"You will not be able to use the features of this application until a Blackmagic device is installed." title:@"This application requires at least one Blackmagic device."];
		goto bail;
	}
	
	screenPreviewCallback = CreateCocoaScreenPreview(previewView);

	result = true;
	
bail:
	if (deckLinkIterator != NULL)
	{
		deckLinkIterator->Release();
		deckLinkIterator = NULL;
	}
	
	return result;
}


int			DeckLinkController::getDeviceCount()
{
	return deviceList.size();
}


NSMutableArray*		DeckLinkController::getDeviceNameList()
{
	NSMutableArray*		nameList = [NSMutableArray array];
	int					deviceIndex = 0;
	
	while (deviceIndex < deviceList.size())
	{		
		CFStringRef	cfStrName;
		
		// Get the name of this device
		if (deviceList[deviceIndex]->GetDisplayName(&cfStrName) == S_OK)
		{		
			[nameList addObject:(NSString *)cfStrName];
			CFRelease(cfStrName);
		}
		else
		{
			[nameList addObject:@"DeckLink"];
		}

		deviceIndex++;
	}
	
	return nameList;
}


bool		DeckLinkController::selectDevice(int index)
{
	IDeckLinkAttributes*			deckLinkAttributes = NULL;
	IDeckLinkDisplayModeIterator*	displayModeIterator = NULL;
	IDeckLinkDisplayMode*			displayMode = NULL;
	bool							result = false;

	// Check index
	if (index >= deviceList.size())
	{
		[uiDelegate showErrorMessage:@"This application was unable to select the device." title:@"Error getting selecting the DeckLink device."];
		goto bail;
	}
	
	// A new device has been selected.
	// Release the previous selected device and mode list
	if (deckLinkInput != NULL)
		deckLinkInput->Release();
	
	while(modeList.size() > 0)
	{
		modeList.back()->Release();
		modeList.pop_back();
	}
	
	
	// Get the IDeckLinkInput for the selected device
	if ((deviceList[index]->QueryInterface(IID_IDeckLinkInput, (void**)&deckLinkInput) != S_OK))
	{
		[uiDelegate showErrorMessage:@"This application was unable to obtain IDeckLinkInput for the selected device." title:@"Error getting setting up capture."];
		deckLinkInput = NULL;
		goto bail;
	}
	
	//
	// Retrieve and cache mode list	
	if (deckLinkInput->GetDisplayModeIterator(&displayModeIterator) == S_OK)
	{
		while (displayModeIterator->Next(&displayMode) == S_OK)
			modeList.push_back(displayMode);

		displayModeIterator->Release();
	}
	
	//
	// Check if input mode detection format is supported.
	
	supportFormatDetection = false;	// assume unsupported until told otherwise
	if (deviceList[index]->QueryInterface(IID_IDeckLinkAttributes, (void**) &deckLinkAttributes) == S_OK)
	{	
		if (deckLinkAttributes->GetFlag(BMDDeckLinkSupportsInputFormatDetection, &supportFormatDetection) != S_OK)
			supportFormatDetection = false;
		
		deckLinkAttributes->Release();
	}
	
	result = true;
	
bail:
	return result;
}

NSMutableArray*		DeckLinkController::getDisplayModeNames()
{
	NSMutableArray*		modeNames = [NSMutableArray array];
	int					modeIndex;
	CFStringRef			modeName;
	
	for (modeIndex = 0; modeIndex < modeList.size(); modeIndex++)
	{			
		if (modeList[modeIndex]->GetName(&modeName) == S_OK)
		{
			[modeNames addObject:(NSString *)modeName];
			CFRelease(modeName);
		}
		else 
		{
			[modeNames addObject:@"Unknown mode"];
		}
	}
	
	return modeNames;
}

bool		DeckLinkController::isFormatDetectionEnabled()
{
	return supportFormatDetection;
}

bool		DeckLinkController::isCapturing()
{
	return currentlyCapturing;
}

bool		DeckLinkController::startCapture(int videoModeIndex)
{
	BMDVideoInputFlags		videoInputFlags;
	
	// Enable input video mode detection if the device supports it
	videoInputFlags = supportFormatDetection ? bmdVideoInputEnableFormatDetection : bmdVideoInputFlagDefault;
	
	// Get the IDeckLinkDisplayMode from the given index
	if ((videoModeIndex < 0) || (videoModeIndex >= modeList.size()))
	{
		[uiDelegate showErrorMessage:@"An invalid display mode was selected." title:@"Error starting the capture"];
		return false;
	}
	
	// Set the screen preview
	deckLinkInput->SetScreenPreviewCallback(screenPreviewCallback);
	
	// Set capture callback
	deckLinkInput->SetCallback(this);
	
	// Set the video input mode
	if (deckLinkInput->EnableVideoInput(modeList[videoModeIndex]->GetDisplayMode(), bmdFormat8BitYUV, videoInputFlags) != S_OK)
	{
		[uiDelegate showErrorMessage:@"This application was unable to select the chosen video mode. Perhaps, the selected device is currently in-use." title:@"Error starting the capture"];
		return false;
	}
	
	// Start the capture
	if (deckLinkInput->StartStreams() != S_OK)
	{
		[uiDelegate showErrorMessage:@"This application was unable to start the capture. Perhaps, the selected device is currently in-use." title:@"Error starting the capture"];
		return false;
	}
	
	currentlyCapturing = true;
	
	return true;
}

void		DeckLinkController::stopCapture()
{
	// Stop the capture
	deckLinkInput->StopStreams();
	
	// Delete capture callback
	deckLinkInput->SetCallback(NULL);
	
	currentlyCapturing = false;
}


HRESULT		DeckLinkController::VideoInputFormatChanged (/* in */ BMDVideoInputFormatChangedEvents notificationEvents, /* in */ IDeckLinkDisplayMode *newMode, /* in */ BMDDetectedVideoInputFormatFlags detectedSignalFlags)
{	
	UInt32				modeIndex = 0;
	
	NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
	
	// Restart capture with the new video mode if told to
	if ([uiDelegate shouldRestartCaptureWithNewVideoMode] == YES)
	{
		// Stop the capture
		deckLinkInput->StopStreams();
		
		// Set the video input mode
		if (deckLinkInput->EnableVideoInput(newMode->GetDisplayMode(), bmdFormat8BitYUV, bmdVideoInputEnableFormatDetection) != S_OK)
		{
			[uiDelegate stopCapture];
			[uiDelegate showErrorMessage:@"This application was unable to select the new video mode." title:@"Error restarting the capture."];
			goto bail;
		}
		
		// Start the capture
		if (deckLinkInput->StartStreams() != S_OK)
		{
			[uiDelegate stopCapture];
			[uiDelegate showErrorMessage:@"This application was unable to start the capture on the selected device." title:@"Error restarting the capture."];
			goto bail;
		}		
	}
	
	// Find the index of the new mode in the mode list so we can update the UI
	while (modeIndex < modeList.size()) {
		if (modeList[modeIndex]->GetDisplayMode() == newMode->GetDisplayMode())
		{
			[uiDelegate selectDetectedVideoModeWithIndex: modeIndex];
			break;
		}
		modeIndex++;
	}
	

bail:
	[pool release];
	return S_OK;
}

HRESULT 	DeckLinkController::VideoInputFrameArrived (/* in */ IDeckLinkVideoInputFrame* videoFrame, /* in */ IDeckLinkAudioInputPacket* audioPacket)
{
	BOOL					hasValidInputSource = (videoFrame->GetFlags() & bmdFrameHasNoInputSource) != 0 ? NO : YES;
	AncillaryDataStruct		ancillaryData;
	
	NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
	
	// Update input source label
	[uiDelegate updateInputSourceState:hasValidInputSource];
	
	// Get the various timecodes and userbits for this frame
	getAncillaryDataFromFrame(videoFrame, bmdTimecodeVITC, &ancillaryData.vitcF1Timecode, &ancillaryData.vitcF1UserBits);
	getAncillaryDataFromFrame(videoFrame, bmdTimecodeVITCField2, &ancillaryData.vitcF2Timecode, &ancillaryData.vitcF2UserBits);
	getAncillaryDataFromFrame(videoFrame, bmdTimecodeRP188VITC1, &ancillaryData.rp188vitc1Timecode, &ancillaryData.rp188vitc1UserBits);
	getAncillaryDataFromFrame(videoFrame, bmdTimecodeRP188LTC, &ancillaryData.rp188ltcTimecode, &ancillaryData.rp188ltcUserBits);
	getAncillaryDataFromFrame(videoFrame, bmdTimecodeRP188VITC2, &ancillaryData.rp188vitc2Timecode, &ancillaryData.rp188vitc2UserBits);
	
	// Update the UI
	[uiDelegate updateAncillaryData:&ancillaryData];
	
	[pool release];
	return S_OK;
}

void	DeckLinkController::getAncillaryDataFromFrame(IDeckLinkVideoInputFrame* videoFrame, BMDTimecodeFormat timecodeFormat, NSString** timecodeString, NSString** userBitsString)
{
	IDeckLinkTimecode*		timecode = NULL;
	CFStringRef				timecodeCFString;
	BMDTimecodeUserBits		userBits = 0;
	
	if ((videoFrame != NULL) && (timecodeString != NULL) && (userBitsString != NULL)
		&& (videoFrame->GetTimecode(timecodeFormat, &timecode) == S_OK))
	{
		if (timecode->GetString(&timecodeCFString) == S_OK)
		{
			*timecodeString = [NSString stringWithString: (NSString *)timecodeCFString];
			CFRelease(timecodeCFString);
		}
		else
		{
			*timecodeString = @"";
		}
		
		timecode->GetTimecodeUserBits(&userBits);
		*userBitsString = [NSString stringWithFormat:@"0x%08X", userBits];
		
		timecode->Release();
	}
	else
	{
		*timecodeString = @"";
		*userBitsString = @"";
	}


}




